# -*- coding: utf-8 -*-
"""coronaVirusReg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FqMxzHnKtOzw7lITS47re8bq3bf4OnyQ
"""

import pandas as pd
import numpy as np

dataset = pd.read_csv('/content/corona_virus.csv', encoding='latin1')
print(dataset.head())
print(dataset.shape)
print(dataset.columns.tolist())
print("\n missing values:")
print(dataset.isnull().sum())
dataset = dataset.drop(index = 231)

dataset.drop(['Country,Other','New Cases', 'New Deaths', 'New Recovered', 'Serious,Critical'], axis=1, inplace=True)
dataset.dropna(inplace=True)
print(dataset.isnull().sum())
print(dataset.shape)

import seaborn as sns
import matplotlib.pyplot as plt
for column in dataset.columns:
    plt.figure(figsize=(6, 4))
    sns.boxplot(data=dataset[column], orient='v')
    plt.title(f'Box Plot for {column}')
    plt.ylabel(column)
    plt.show()

for column in dataset.columns:
    if dataset[column].dtype == 'object':
        try:
            dataset[column] = pd.to_numeric(dataset[column].str.replace(',', ''), errors='coerce')
        except AttributeError:
            pass
dataset.corr()['Total Deaths'].abs().sort_values()

import matplotlib.pyplot as plt
import seaborn as sns
correlation_matrix = dataset.corr()
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Heatmap')
plt.show()

from sklearn.model_selection import train_test_split
x=dataset.drop(['Total Deaths'],axis=1).values
y=dataset['Total Deaths'].values
xtrain, xtest, ytrain, ytest = train_test_split(x, y, test_size=0.2, random_state=0)

#pipline
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import MinMaxScaler
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.svm import SVR
from sklearn.tree import DecisionTreeRegressor
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import r2_score
from sklearn.model_selection import cross_val_score

models = {
    "Linear Regression": LinearRegression(),
    "Random Forest": RandomForestRegressor(n_estimators=100, random_state=0),
    "Support Vector Machine": SVR(),
    "Decision Tree": DecisionTreeRegressor(),
    "K-Nearest Neighbors": KNeighborsRegressor()
}

for model_name, model in models.items():
  pipline = Pipeline([
      ('scaler', MinMaxScaler()),
      ('regressor', model)
  ])
  pipline.fit(xtrain, ytrain)
  yp = pipline.predict(xtest)
  r2 = r2_score(ytest, yp)
  print(f"{model_name} R2 Score: {r2}")
  #cross validation
  scores = cross_val_score(pipline, x, y, cv=5, scoring='r2')
  print(f"{model_name} - Cross-Validation R^2 Scores: {scores}")
  print(f"{model_name} - Mean Cross-Validation R^2 Score: {scores.mean()}")

#not important
from sklearn.preprocessing import MinMaxScaler
sc = MinMaxScaler()
xtrain = sc.fit_transform(xtrain)
xtest = sc.transform(xtest)

from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
regressor = LinearRegression()
regressor.fit(xtrain, ytrain)
yp=regressor.predict(xtest)
print(r2_score(ytest,yp))

scores = cross_val_score(regressor, x, y, cv=5, scoring='r2')
print(f"Linear Regression - Cross-Validation R^2 Scores: {scores}")
print(f"Linear Regression - Mean Cross-Validation R^2 Score: {scores.mean()}")

from sklearn.ensemble import RandomForestRegressor
regressor = RandomForestRegressor(n_estimators=100, random_state=0)
regressor.fit(xtrain, ytrain)
yp=regressor.predict(xtest)
print(r2_score(ytest,yp))

from sklearn.svm import SVR
regressor = SVR()
regressor.fit(xtrain, ytrain)
yp=regressor.predict(xtest)
print(r2_score(ytest,yp))

from sklearn.tree import DecisionTreeRegressor
regressor = DecisionTreeRegressor()
regressor.fit(xtrain, ytrain)
yp=regressor.predict(xtest)
print(r2_score(ytest,yp))

from sklearn.neighbors import KNeighborsRegressor
regressor = KNeighborsRegressor()
regressor.fit(xtrain, ytrain)
yp=regressor.predict(xtest)
print(r2_score(ytest,yp))

import matplotlib.pyplot as plt
for i in range(8):
    plt.scatter(ytest,xtest[:,i],color='blue')
    plt.show()
    plt.scatter(yp, xtest[:,i],color='red')
    plt.show()